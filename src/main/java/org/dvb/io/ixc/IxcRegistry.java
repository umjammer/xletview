/*

 This file is part of XleTView
 Copyright (C) 2004 Christian Koeberl

 This is free software, and you are
 welcome to redistribute it under
 certain conditions;

 See LICENSE document for details.

 */

package org.dvb.io.ixc;

import java.rmi.AlreadyBoundException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.util.HashMap;
import java.util.Map;

import org.dvb.application.AppID;

import xjavax.tv.xlet.XletContext;

/**
 * This is the bootstrap mechanism for obtaining references to remote objects
 * residing in other Xlets executing on the same MHP terminal, using a
 * URL-like syntax. The identification of a remote object is given using a
 * syntax indicating the organisation ID and application ID:
 * "/organisation_id/application_id/name".
 * <ul>
 * <li>organisation_id = the organisation ID of the Xlet, as signalled in the
 * application_identifier record, defined in the MHP specification.
 * <li>application_id = the application ID of the Xlet, as signalled in the
 * application_identifier record, defined in the MHP specification.
 * <li>name = the name under which the remote object was exported.
 * </ul>
 * <p>
 * The organisation ID and the application ID shall each be encoded as a
 * hexadecimal string, as would be accepted by
 * <code>java.lang.Integer.parseInt(String s, 16)</code>.
 * <p>
 * When RMI is used to communicate over a network, stubs generated by a tool
 * like rmic are often required. This is not necessary for inter-xlet
 * communication initiated with IxcRegistry. If such stubs are present, they
 * shall be ignored.
 * <p>
 * Similarly, network RMI objects often extend the class server.RemoteObject,
 * in order to get appropriate implementations for Object.hashCode(),
 * Object.equals(), and Object.toString(). Overriding Objectï¿½s implementation
 * of these methods in this way is not necessary for inter-xlet communication
 * initiated with IxcRegistry, although it is not harmful. Note that the class
 * server.RemoteObject is not required in all MHP profiles.
 *
 * @author Christian K&ouml;berl
 * @version $Revision: 1.4 $
 */
public class IxcRegistry {

    private static class RegistryEntry {

        public RegistryEntry(Remote obj, boolean external) {
            this.object = obj;
            this.external = external;
        }

        Remote object;

        boolean external;
    }

    private static Map<String, RegistryEntry> registry = new HashMap<>();

    private IxcRegistry() {
    }

    public static Remote lookup(xjavax.tv.xlet.XletContext xc, String name)
            throws NotBoundException, RemoteException {
        RegistryEntry entry;
        synchronized (registry) {
            entry = (RegistryEntry) registry.get(name);
        }
        if (entry == null) throw new NotBoundException();

        AppID thisAppId = getAppID(xc);
        AppID lookupAppId = getAppID(name);
        if (thisAppId != null
                && (thisAppId.equals(lookupAppId) || entry.external))
            return entry.object;
        else
            throw new NotBoundException();
    }

    public static void bind(xjavax.tv.xlet.XletContext xc, String name,
            Remote obj) throws AlreadyBoundException {
        bind(xc, name, obj, true);
    }

    public static void bind(xjavax.tv.xlet.XletContext xc, String name,
            Remote obj, boolean external) throws AlreadyBoundException {
        AppID thisAppId = getAppID(xc);
        name = "/" + Integer.toHexString(thisAppId.getOID()) + "/"
                + Integer.toHexString(thisAppId.getAID()) + "/" + name;

        synchronized (registry) {
            RegistryEntry entry = (RegistryEntry) registry.get(name);
            if (entry != null) throw new AlreadyBoundException();
            registry.put(name, new RegistryEntry(obj, external));
        }
    }

    public static void rebind(xjavax.tv.xlet.XletContext xc, String name,
            Remote obj) {
        rebind(xc, name, obj, true);
    }

    public static void unbind(xjavax.tv.xlet.XletContext xc, String name)
            throws NotBoundException {
        AppID thisAppId = getAppID(xc);
        name = "/" + Integer.toHexString(thisAppId.getOID()) + "/"
                + Integer.toHexString(thisAppId.getAID()) + "/" + name;

        synchronized (registry) {
            if (registry.remove(name) == null) throw new NotBoundException();
        }
    }

    public static void rebind(xjavax.tv.xlet.XletContext xc, String name,
            Remote obj, boolean external) {
        AppID thisAppId = getAppID(xc);
        name = "/" + Integer.toHexString(thisAppId.getOID()) + "/"
                + Integer.toHexString(thisAppId.getAID()) + "/" + name;
        synchronized (registry) {
            registry.put(name, new RegistryEntry(obj, external));
        }
    }

    public static String[] list(xjavax.tv.xlet.XletContext xc) {
        String[] list;
        synchronized (registry) {
            list = new String[registry.size()];
            registry.keySet().toArray(list);
        }
        return list;
    }

    private static AppID getAppID(XletContext xc) {
        try {
            int orgid = Integer.parseInt((String) xc
                    .getXletProperty("dvb.org.id"), 16);
            int appid = Integer.parseInt((String) xc
                    .getXletProperty("dvb.app.id"), 16);
            return new AppID(orgid, appid);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    private static AppID getAppID(String name) {
        String[] split = name.split("/");
        if (split.length < 2) return null;
        try {
            int orgid = Integer.parseInt(split[0], 16);
            int appid = Integer.parseInt(split[1], 16);
            return new AppID(orgid, appid);
        } catch (NumberFormatException e) {
            return null;
        }
    }
}